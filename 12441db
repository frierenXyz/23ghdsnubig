-- DEATH BALL PRO: V14.6 (OPTIMIZED TIMING)
-- Fixed version with improved timing and background operation

-- // 0. CLEANUP SYSTEM //
local ScriptKey = "BURAT_PRO_V14"
local getgenv = getgenv or function() return _G end

if getgenv()[ScriptKey] then
    if getgenv()[ScriptKey].Connection then getgenv()[ScriptKey].Connection:Disconnect() end
    if getgenv()[ScriptKey].SpamConnection then getgenv()[ScriptKey].SpamConnection:Disconnect() end
    if getgenv()[ScriptKey].UI and getgenv()[ScriptKey].UI.Parent then getgenv()[ScriptKey].UI:Destroy() end
    if getgenv()[ScriptKey].AFKLoop then task.cancel(getgenv()[ScriptKey].AFKLoop) end
end

getgenv()[ScriptKey] = { 
    Connection = nil, 
    SpamConnection = nil,
    UI = nil, 
    AFKLoop = nil 
}

-- ==========================================
-- OPTIMIZED TIMING CONSTANTS
-- ==========================================

local ParryDuration = 0.30
local HitDelayCheck = 0.25
local MinRange = 5.0
local MaxRange = 40
local AccelerationThreshold = 80
local MaxAcceleration = 600
local ReactionBoost = 2.80
local CloseCombatThreshold = 15
local RapidSpamCooldown = 0.00001
local CurveRecoveryTime = 0.5
local DirectionChangeThreshold = 80
local CURVE_STRENGTH_MULTIPLIER = 2.5
local BACKWARD_CURVE_FACTOR = 1.14
local VERTICAL_CURVE_FACTOR = 1.10
local HORIZONTAL_CURVE_FACTOR = 1.4

-- OPTIMIZED TIMING
local OPTIMAL_PARRY_WINDOW = 0.5  -- Best time to parry (reduced from 0.12)
local MIN_PARRY_WINDOW = 0.06      -- Minimum window for parry
local MAX_PARRY_WINDOW = 0.20      -- Maximum window for parry
local VELOCITY_SMOOTHING = 0.82    -- Smoother velocity tracking
local POSITION_PREDICTION_ACCURACY = 0.80  -- More accurate prediction
local ADAPTIVE_TIMING_FACTOR = 0.80  -- Reduced for better timing

-- CURVE-BACK DETECTION (ALWAYS ENABLED)
local CURVE_BACK_COOLDOWN_MULTIPLIER = 0.35  -- Balanced cooldown reduction
local PASS_BY_DETECTION_WINDOW = 0.7         -- Slightly shorter window
local PASS_BY_THRESHOLD = 10                 -- Closer pass-by detection
local CURVE_BACK_ANGLE_THRESHOLD = 90        -- Slightly lower angle threshold
local REATTEMPT_DELAY = 0.12                 -- Faster reattempt

-- ==========================================

-- // SERVICES //
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = workspace.CurrentCamera

local IS_MOBILE = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- // 1. UI LIBRARY // --
local Library = {}
local GUI_NAME = "BURAT_PRO"
local THEME = {
    Background = Color3.fromRGB(20, 20, 25),
    Header     = Color3.fromRGB(25, 25, 30),
    Section    = Color3.fromRGB(30, 30, 35),
    Text       = Color3.fromRGB(255, 255, 255),
    Accent     = Color3.fromRGB(255, 0, 0),
    DarkText   = Color3.fromRGB(150, 150, 150),
    Stroke     = Color3.fromRGB(50, 50, 55)
}

local function Create(class, props)
    local inst = Instance.new(class)
    for k, v in pairs(props) do inst[k] = v end
    return inst
end

local function MakeDraggable(topbar, widget)
    local dragging, dragInput, dragStart, startPos
    local function Update(input)
        local delta = input.Position - dragStart
        local targetPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        TweenService:Create(widget, TweenInfo.new(0.05), {Position = targetPos}):Play()
    end
    topbar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true; dragStart = input.Position; startPos = widget.Position
            input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
        end
    end)
    topbar.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then dragInput = input end end)
    UserInputService.InputChanged:Connect(function(input) if input == dragInput and dragging then Update(input) end end)
end

function Library:CreateWindow(config)
    local Title = config.Title or "UI Library"
    local OldInstance = PlayerGui:FindFirstChild(GUI_NAME)
    if OldInstance then OldInstance:Destroy() end

    local ScreenGui = Create("ScreenGui", {Name = GUI_NAME, Parent = PlayerGui, ResetOnSpawn = false, ZIndexBehavior = Enum.ZIndexBehavior.Sibling, IgnoreGuiInset = true})
    getgenv()[ScriptKey].UI = ScreenGui

    local MainFrame = Create("Frame", {Name = "MainFrame", Parent = ScreenGui, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0, 500, 0, 400), BackgroundColor3 = THEME.Background, ClipsDescendants = true})
    Create("UICorner", {Parent = MainFrame, CornerRadius = UDim.new(0, 10)}); Create("UIStroke", {Parent = MainFrame, Color = THEME.Accent, Thickness = 2, ApplyStrokeMode = Enum.ApplyStrokeMode.Border})

    local Topbar = Create("Frame", {Parent = MainFrame, BackgroundColor3 = THEME.Header, Size = UDim2.new(1, 0, 0, 40), BorderSizePixel = 0})
    MakeDraggable(Topbar, MainFrame)
    Create("TextLabel", {Parent = Topbar, BackgroundTransparency = 1, Position = UDim2.new(0, 15, 0, 0), Size = UDim2.new(0.6, 0, 1, 0), Font = Enum.Font.GothamBold, Text = Title, TextColor3 = THEME.Text, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left})

    local Controls = Create("Frame", {Parent = Topbar, AnchorPoint = Vector2.new(1, 0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 30, 0, 24), BackgroundTransparency = 1})
    
    local ExitBtn = Create("TextButton", {Parent = Controls, BackgroundColor3 = THEME.Accent, Size = UDim2.new(0, 24, 0, 24), Text = "X", Font = Enum.Font.GothamBold, TextColor3 = Color3.new(1,1,1), AutoButtonColor = false})
    Create("UICorner", {Parent = ExitBtn, CornerRadius = UDim.new(0, 4)})

    ExitBtn.MouseButton1Click:Connect(function() 
        ScreenGui:Destroy()
        if getgenv()[ScriptKey].Connection then getgenv()[ScriptKey].Connection:Disconnect() end
        if getgenv()[ScriptKey].SpamConnection then getgenv()[ScriptKey].SpamConnection:Disconnect() end
        if getgenv()[ScriptKey].AFKLoop then task.cancel(getgenv()[ScriptKey].AFKLoop) end
    end)

    local Sidebar = Create("Frame", {Parent = MainFrame, BackgroundColor3 = THEME.Section, Position = UDim2.new(0, 0, 0, 40), Size = UDim2.new(0, 140, 1, -40), BorderSizePixel = 0})
    Create("UIListLayout", {Parent = Sidebar, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 5)}); Create("UIPadding", {Parent = Sidebar, PaddingTop = UDim.new(0, 10), PaddingLeft = UDim.new(0, 10), PaddingRight = UDim.new(0, 10)})
    local PageContainer = Create("Frame", {Parent = MainFrame, BackgroundTransparency = 1, Position = UDim2.new(0, 150, 0, 50), Size = UDim2.new(1, -160, 1, -60)})

    local WindowObj = {Tabs = {}}
    local FirstTab = true

    function WindowObj:CreateTab(name)
        local TabBtn = Create("TextButton", {Parent = Sidebar, BackgroundColor3 = THEME.Section, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 30), Text = name, Font = Enum.Font.GothamMedium, TextColor3 = THEME.DarkText, TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, AutoButtonColor = false})
        Create("UICorner", {Parent = TabBtn, CornerRadius = UDim.new(0, 6)}); Create("UIPadding", {Parent = TabBtn, PaddingLeft = UDim.new(0, 8)})
        local Page = Create("ScrollingFrame", {Parent = PageContainer, Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 1, Visible = false, ScrollBarThickness = 2, ScrollBarImageColor3 = THEME.Accent, BorderSizePixel = 0})
        local PageLayout = Create("UIListLayout", {Parent = Page, SortOrder = Enum.SortOrder.LayoutOrder, Padding = UDim.new(0, 6)})
        PageLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() Page.CanvasSize = UDim2.new(0, 0, 0, PageLayout.AbsoluteContentSize.Y + 20) end)

        local function Activate()
            for _, v in pairs(WindowObj.Tabs) do TweenService:Create(v.Btn, TweenInfo.new(0.2), {TextColor3 = THEME.DarkText}):Play(); v.Page.Visible = false end
            TweenService:Create(TabBtn, TweenInfo.new(0.2), {TextColor3 = THEME.Accent}):Play(); Page.Visible = true
        end
        TabBtn.MouseButton1Click:Connect(Activate)
        if FirstTab then FirstTab = false; Activate() end
        table.insert(WindowObj.Tabs, {Btn = TabBtn, Page = Page})

        local Elements = {}
        function Elements:CreateSection(text) 
            local section = Create("TextLabel", {Parent = Page, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 25), Text = text:upper(), Font = Enum.Font.GothamBold, TextColor3 = THEME.DarkText, TextSize = 11, TextXAlignment = Enum.TextXAlignment.Left})
            return section
        end
        
        function Elements:CreateButton(text, callback)
            callback = callback or function() end
            local Btn = Create("TextButton", {Parent = Page, BackgroundColor3 = THEME.Section, Size = UDim2.new(1, -5, 0, 32), Text = text, Font = Enum.Font.Gotham, TextColor3 = THEME.Text, TextSize = 13, AutoButtonColor = false})
            Create("UICorner", {Parent = Btn, CornerRadius = UDim.new(0, 6)}); Create("UIStroke", {Parent = Btn, Color = THEME.Stroke, Thickness = 1})
            Btn.MouseButton1Click:Connect(function()
                TweenService:Create(Btn, TweenInfo.new(0.1), {BackgroundColor3 = THEME.Accent}):Play()
                task.wait(0.1)
                TweenService:Create(Btn, TweenInfo.new(0.2), {BackgroundColor3 = THEME.Section}):Play()
                callback(Btn)
            end)
            return Btn
        end

        function Elements:CreateToggle(text, callback)
            callback = callback or function() end
            local Toggled = false
            local Btn = Create("TextButton", {Parent = Page, BackgroundColor3 = THEME.Section, Size = UDim2.new(1, -5, 0, 32), Text = "", AutoButtonColor = false})
            Create("UICorner", {Parent = Btn, CornerRadius = UDim.new(0, 6)}); Create("UIStroke", {Parent = Btn, Color = THEME.Stroke, Thickness = 1})
            Create("TextLabel", {Parent = Btn, BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -50, 1, 0), Text = text, Font = Enum.Font.Gotham, TextColor3 = THEME.Text, TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left})
            local Tracker = Create("Frame", {Parent = Btn, BackgroundColor3 = Color3.fromRGB(30, 30, 30), AnchorPoint = Vector2.new(1, 0.5), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 36, 0, 18)}); Create("UICorner", {Parent = Tracker, CornerRadius = UDim.new(1, 0)})
            local Dot = Create("Frame", {Parent = Tracker, BackgroundColor3 = Color3.fromRGB(100, 100, 100), AnchorPoint = Vector2.new(0, 0.5), Position = UDim2.new(0, 2, 0.5, 0), Size = UDim2.new(0, 14, 0, 14)}); Create("UICorner", {Parent = Dot, CornerRadius = UDim.new(1, 0)})
            Btn.MouseButton1Click:Connect(function()
                Toggled = not Toggled
                local TargetPos = Toggled and UDim2.new(0, 20, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
                local TargetColor = Toggled and THEME.Accent or Color3.fromRGB(30, 30, 30)
                local DotColor = Toggled and Color3.new(1,1,1) or Color3.fromRGB(100,100,100)
                TweenService:Create(Dot, TweenInfo.new(0.2), {Position = TargetPos, BackgroundColor3 = DotColor}):Play()
                TweenService:Create(Tracker, TweenInfo.new(0.2), {BackgroundColor3 = TargetColor}):Play()
                callback(Toggled)
            end)
        end

        function Elements:CreateSlider(text, min, max, default, callback)
            callback = callback or function() end
            local SliderFrame = Create("Frame", {Parent = Page, BackgroundColor3 = THEME.Section, Size = UDim2.new(1, -5, 0, 40)})
            Create("UICorner", {Parent = SliderFrame, CornerRadius = UDim.new(0, 6)})
            Create("UIStroke", {Parent = SliderFrame, Color = THEME.Stroke, Thickness = 1})
            local Label = Create("TextLabel", {Parent = SliderFrame, BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -20, 0, 20), Text = text .. ": " .. default, Font = Enum.Font.Gotham, TextColor3 = THEME.Text, TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left})
            local Bar = Create("Frame", {Parent = SliderFrame, BackgroundColor3 = Color3.fromRGB(50,50,50), Position = UDim2.new(0, 10, 0, 25), Size = UDim2.new(1, -20, 0, 10)})
            Create("UICorner", {Parent = Bar, CornerRadius = UDim.new(0, 5)})
            local Fill = Create("Frame", {Parent = Bar, BackgroundColor3 = THEME.Accent, Size = UDim2.new((default - min)/(max - min), 0, 1, 0)})
            Create("UICorner", {Parent = Fill, CornerRadius = UDim.new(0, 5)})
            local Knob = Create("Frame", {Parent = Bar, BackgroundColor3 = THEME.Text, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.new((default - min)/(max - min), 0, 0.5, 0), Size = UDim2.new(0, 16, 0, 16)})
            Create("UICorner", {Parent = Knob, CornerRadius = UDim.new(1, 0)})
            
            local Value = default
            local dragging = false
            local function UpdateSlider(input)
                local relativeX = math.clamp((input.Position.X - Bar.AbsolutePosition.X) / Bar.AbsoluteSize.X, 0, 1)
                Value = math.floor(min + (max - min) * relativeX)
                Fill.Size = UDim2.new(relativeX, 0, 1, 0)
                Knob.Position = UDim2.new(relativeX, 0, 0.5, 0)
                Label.Text = text .. ": " .. Value
                callback(Value)
            end
            Bar.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = true
                    UpdateSlider(input)
                end
            end)
    Bar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            UpdateSlider(input)
        end
    end)
    return SliderFrame
end
        return Elements
    end
    return WindowObj
end

-- // 2. CONFIGURATION & STATE // --
local Config = {
    Enabled = false,
    ManualSpam = false,
    AutoSpam = false,
    AutoCurve = false,
    CurveMode = "Up",
    Debug = false,
    SpamIntensity = "Extreme",
    InvisibleCurve = false,
    ShowHitbox = false,
    ManualOffset = 0,
    PerfectMode = true,
    AccuracyBoost = 100,
    AntiCurveMode = true,
    MinimizeKeybind = Enum.KeyCode.LeftControl,
    ManualSpamKeybind = Enum.KeyCode.V,
    IsListeningForKey = false,
    FOV = 70,
    AntiAFK = false,
    MaxCamera = false,
    AggressiveFPS = false,
    Enable360Detection = true,
    AcceleratedMode = true,
    FastReaction = true,
    -- Smart cooldown and curve-back detection ALWAYS ENABLED
}

local State = {
    BallShadow = nil,
    BallObject = nil,
    PreviousPosition = nil,
    PreviousVelocity = nil,
    LastParry = 0,
    IsCurving = false,
    ConsecutiveDetections = 0,
    VelocityHistory = {},
    PingHistory = {},
    HitboxVisualizer = nil,
    PositionHistory = {},
    TripleVectorHistory = {},
    SmoothedVelocity = Vector3.new(0, 0, 0),
    PerfectConfidence = 0,
    QuantumPrediction = Vector3.new(0, 0, 0),
    SuccessfulParries = 0,
    TotalAttempts = 0,
    CurveStrength = 0,
    IsSkillActive = false,
    CurveType = "None",
    JerkLevel = 0,
    IsManualSpamming = false,
    CloseCombatActive = false,
    ManualSpamRunning = false,
    TrajectoryHistory = {},
    LastSpamTime = 0,
    AccelerationHistory = {},
    IsAccelerated = false,
    AccelerationBoost = 1.0,
    LastAccelerationTime = 0,
    UltraCloseMode = false,
    IsCurveRecovery = false,
    CurveRecoveryStart = 0,
    LastDirectionChange = 0,
    DirectionHistory = {},
    VelocityAngles = {},
    BackwardCurveDetected = false,
    UpwardCurveDetected = false,
    DownwardCurveDetected = false,
    LeftCurveDetected = false,
    RightCurveDetected = false,
    CurveDirectionVector = Vector3.new(0, 0, 0),
    BackwardCurveStrength = 0,
    VerticalCurveStrength = 0,
    HorizontalCurveStrength = 0,
    
    -- TIMING VARIABLES
    LastPredictionTime = 0,
    PredictionHistory = {},
    TimingAdjustment = 1.0,
    HitProbability = 0,
    ParryWindowStart = 0,
    OptimalParryTime = 0,
    ReactionTimeHistory = {},
    AverageReactionTime = 0.15,
    PingCompensation = 0,
    NetworkLag = 0,
    
    -- CURVE-BACK DETECTION VARIABLES (ALWAYS ACTIVE)
    LastMissedParryTime = 0,
    PassByHistory = {},
    CurveBackDetected = false,
    CurveBackStartTime = 0,
    PassByDistanceHistory = {},
    LastPassByTime = 0,
    PassByDirection = Vector3.new(0, 0, 0),
    CurveBackConfidence = 0,
    MissedOpportunities = 0,
    AdaptiveCooldownMultiplier = 1.0,
    CooldownOverrideActive = false,
    CooldownOverrideEnd = 0,
    RecentParryAttempts = {},
    SmartParryEnabled = true,
    TimingHistory = {},  -- NEW: Track timing success
    OptimalParryOffset = 0,  -- NEW: Adjust parry timing
}

local CurveModes = {"Up", "Down", "Back", "Left", "Right", "Random"}
local CurveIndex = 1

-- // 3. OPTIMIZED TIMING FUNCTIONS // --
local function GetBallColor(target)
    if not target then return Color3.new(1, 1, 1) end
    local highlight = target:FindFirstChildOfClass("Highlight")
    if highlight then return highlight.FillColor end
    return target:IsA("Part") and target.Color or Color3.new(1, 1, 1)
end

local function GetVisualHeight(shadow)
    if not shadow then return 0 end
    return math.min(((math.max(0, shadow.Size.X - 5)) * 20) + 3, 100)
end

-- OPTIMIZED PING MEASUREMENT
local function GetPingVariance()
    local ping = LocalPlayer:GetNetworkPing()
    State.PingHistory = State.PingHistory or {}
    table.insert(State.PingHistory, ping)
    if #State.PingHistory > 20 then table.remove(State.PingHistory, 1) end
    
    local minP, maxP = 1000, 0
    local totalPing = 0
    for _, p in ipairs(State.PingHistory) do
        if p < minP then minP = p end
        if p > maxP then maxP = p end
        totalPing = totalPing + p
    end
    
    State.AveragePing = totalPing / #State.PingHistory
    State.PingCompensation = State.AveragePing * 1000 * 0.001
    
    return (maxP - minP), ping
end

-- DETECT PASS-BY SCENARIOS (ALWAYS ACTIVE)
local function DetectPassByScenario(currentPos, velocityVec, rootPos)
    local distance = (rootPos - currentPos).Magnitude
    local dirToPlayer = (rootPos - currentPos).Unit
    local dirOfBall = velocityVec.Unit
    local dotProduct = dirToPlayer:Dot(dirOfBall)
    
    -- Track pass-by distances
    State.PassByDistanceHistory = State.PassByDistanceHistory or {}
    table.insert(State.PassByDistanceHistory, {
        distance = distance,
        time = os.clock(),
        dotProduct = dotProduct,
        position = currentPos,
        velocity = velocityVec
    })
    
    -- Keep only recent history
    while #State.PassByDistanceHistory > 12 do
        table.remove(State.PassByDistanceHistory, 1)
    end
    
    -- Find minimum pass-by distance
    local minPassByDistance = 1000
    local passByTime = 0
    
    for i, data in ipairs(State.PassByDistanceHistory) do
        if data.distance < minPassByDistance then
            minPassByDistance = data.distance
            passByTime = data.time
        end
    end
    
    -- Check if we recently had a pass-by
    local timeSincePassBy = os.clock() - passByTime
    local isRecentPassBy = timeSincePassBy < PASS_BY_DETECTION_WINDOW and minPassByDistance < PASS_BY_THRESHOLD
    
    -- Check for curve-back pattern
    local curveBackConfidence = 0
    if isRecentPassBy and #State.PassByDistanceHistory >= 4 then
        local earlyData = State.PassByDistanceHistory[1]
        local recentData = State.PassByDistanceHistory[#State.PassByDistanceHistory]
        
        -- Calculate direction changes
        local earlyToPlayer = (rootPos - earlyData.position).Unit
        local earlyDir = earlyData.velocity.Unit
        local earlyDot = earlyToPlayer:Dot(earlyDir)
        
        local recentToPlayer = (rootPos - recentData.position).Unit
        local recentDir = recentData.velocity.Unit
        local recentDot = recentToPlayer:Dot(recentDir)
        
        -- Detect curve-back pattern (from moving away to moving toward)
        if earlyDot < -0.2 and recentDot > 0.3 and minPassByDistance < 12 then
            curveBackConfidence = math.min(1.0, (recentDot - earlyDot) * 1.5)
            
            -- Calculate angle change
            local angleChange = math.deg(math.acos(math.clamp(earlyDir:Dot(recentDir), -1, 1)))
            if angleChange > CURVE_BACK_ANGLE_THRESHOLD then
                curveBackConfidence = curveBackConfidence * 1.3
            end
            
            if Config.Debug and curveBackConfidence > 0.5 then
                print(string.format("[CURVE-BACK] Confidence: %.2f | Angle: %.1fÂ°", 
                    curveBackConfidence, angleChange))
            end
        end
    end
    
    return isRecentPassBy, minPassByDistance, curveBackConfidence
end

-- OPTIMIZED COOLDOWN CALCULATION
local function CalculateSmartCooldown(velocityMag, isCurveBack, curveBackConfidence)
    -- Base cooldown based on velocity
    local baseCooldown = 0.015  -- Reduced from 0.018
    if velocityMag > 240 then baseCooldown = 0.0006  -- Reduced
    elseif velocityMag > 200 then baseCooldown = 0.0009
    elseif velocityMag > 170 then baseCooldown = 0.0014
    elseif velocityMag > 140 then baseCooldown = 0.0018
    elseif velocityMag > 110 then baseCooldown = 0.0022
    elseif velocityMag > 80 then baseCooldown = 0.0028
    end
    
    -- Adjust for acceleration
    if State.IsAccelerated then
        baseCooldown = baseCooldown * (0.85 / State.AccelerationBoost)
    end
    
    -- Adjust for close combat
    if State.CloseCombatActive then
        baseCooldown = baseCooldown * 0.3
    end
    
    if State.UltraCloseMode then
        baseCooldown = baseCooldown * 0.2
    end
    
    -- Adjust for skill detection
    if State.IsSkillActive then baseCooldown = baseCooldown * 0.5 end
    if State.PerfectConfidence > 92 then baseCooldown = baseCooldown * 0.6 end
    
    -- SPECIAL: Curve-back scenario handling
    if isCurveBack and curveBackConfidence > 0.6 then
        -- Reduce cooldown for curve-back scenarios
        local curveBackMultiplier = CURVE_BACK_COOLDOWN_MULTIPLIER * (1.0 - curveBackConfidence * 0.3)
        baseCooldown = baseCooldown * curveBackMultiplier
        
        -- Add extra reduction if we recently missed a parry
        local timeSinceMiss = os.clock() - State.LastMissedParryTime
        if timeSinceMiss < REATTEMPT_DELAY then
            baseCooldown = baseCooldown * 0.4
        end
    end
    
    -- Apply adaptive multiplier
    baseCooldown = baseCooldown * State.AdaptiveCooldownMultiplier
    
    -- Clamp minimum cooldown
    baseCooldown = math.max(0.00008, baseCooldown)
    
    return baseCooldown
end

-- TRACK PARRY ATTEMPTS FOR ADAPTIVE TIMING
local function TrackParryAttempt(success, timingOffset)
    State.RecentParryAttempts = State.RecentParryAttempts or {}
    State.TimingHistory = State.TimingHistory or {}
    
    table.insert(State.RecentParryAttempts, {
        time = os.clock(),
        success = success
    })
    
    -- Track timing offset for optimization
    if timingOffset then
        table.insert(State.TimingHistory, timingOffset)
        if #State.TimingHistory > 10 then
            table.remove(State.TimingHistory, 1)
        end
    end
    
    -- Keep only recent attempts
    while #State.RecentParryAttempts > 8 do
        table.remove(State.RecentParryAttempts, 1)
    end
    
    -- Calculate success rate
    local totalAttempts = #State.RecentParryAttempts
    local successfulAttempts = 0
    
    for _, attempt in ipairs(State.RecentParryAttempts) do
        if attempt.success then
            successfulAttempts = successfulAttempts + 1
        end
    end
    
    local successRate = totalAttempts > 0 and (successfulAttempts / totalAttempts) or 1.0
    
    -- Adjust adaptive cooldown multiplier based on success rate
    if totalAttempts >= 4 then
        if successRate < 0.4 then
            -- Too many misses, reduce cooldown
            State.AdaptiveCooldownMultiplier = math.max(0.6, State.AdaptiveCooldownMultiplier * 0.95)
        elseif successRate > 0.8 then
            -- Good success rate, maintain or slightly increase
            State.AdaptiveCooldownMultiplier = math.min(1.2, State.AdaptiveCooldownMultiplier * 1.02)
        else
            -- Balanced, return to normal
            State.AdaptiveCooldownMultiplier = State.AdaptiveCooldownMultiplier * 0.99 + 0.01
            State.AdaptiveCooldownMultiplier = math.clamp(State.AdaptiveCooldownMultiplier, 0.6, 1.2)
        end
        
        -- Calculate optimal timing offset
        if #State.TimingHistory >= 3 then
            local totalOffset = 0
            for _, offset in ipairs(State.TimingHistory) do
                totalOffset = totalOffset + offset
            end
            State.OptimalParryOffset = totalOffset / #State.TimingHistory * 0.5  -- Apply 50% of calculated offset
            State.OptimalParryOffset = math.clamp(State.OptimalParryOffset, -0.05, 0.05)  -- Clamp to reasonable range
        end
    end
    
    -- Track missed parry for curve-back detection
    if not success then
        State.LastMissedParryTime = os.clock()
        State.MissedOpportunities = State.MissedOpportunities + 1
        
        -- If we've missed multiple times, enable cooldown override
        if State.MissedOpportunities >= 2 and os.clock() - State.LastMissedParryTime < 0.8 then
            State.CooldownOverrideActive = true
            State.CooldownOverrideEnd = os.clock() + 0.4
            State.AdaptiveCooldownMultiplier = 0.4
        end
    else
        State.MissedOpportunities = math.max(0, State.MissedOpportunities - 1)
    end
    
    -- Check if cooldown override should end
    if State.CooldownOverrideActive and os.clock() > State.CooldownOverrideEnd then
        State.CooldownOverrideActive = false
        State.AdaptiveCooldownMultiplier = 1.0
    end
end

-- OPTIMIZED VELOCITY SMOOTHING
local function QuantumSmoothVelocity(currentVel, velocityMag, ping)
    local alpha = VELOCITY_SMOOTHING
    if velocityMag > 200 then alpha = 0.90
    elseif velocityMag > 150 then alpha = 0.86
    elseif velocityMag < 60 then alpha = 0.75
    end
    
    if ping * 1000 > 200 then alpha = alpha + 0.06 end
    if State.IsAccelerated then alpha = alpha + 0.04 end
    
    State.SmoothedVelocity = State.SmoothedVelocity:Lerp(currentVel, alpha)
    return State.SmoothedVelocity
end

-- OPTIMIZED ACCELERATION DETECTION
local function DetectAcceleration(velocityVec, velocityMag)
    State.VelocityHistory = State.VelocityHistory or {}
    table.insert(State.VelocityHistory, velocityMag)
    if #State.VelocityHistory > 8 then
        table.remove(State.VelocityHistory, 1)
    end
    
    if #State.VelocityHistory >= 3 then
        local recentAcceleration = 0
        local accelerationSamples = {}
        
        for i = 2, #State.VelocityHistory do
            local accel = State.VelocityHistory[i] - State.VelocityHistory[i-1]
            table.insert(accelerationSamples, accel)
            recentAcceleration = recentAcceleration + accel
        end
        
        recentAcceleration = recentAcceleration / math.max(1, #accelerationSamples)
        State.AccelerationHistory = State.AccelerationHistory or {}
        table.insert(State.AccelerationHistory, recentAcceleration)
        
        if #State.AccelerationHistory > 6 then
            table.remove(State.AccelerationHistory, 1)
        end
        
        local avgAcceleration = 0
        for _, accel in ipairs(State.AccelerationHistory) do
            avgAcceleration = avgAcceleration + accel
        end
        avgAcceleration = avgAcceleration / math.max(1, #State.AccelerationHistory)
        
        if avgAcceleration > AccelerationThreshold then
            State.IsAccelerated = true
            State.LastAccelerationTime = os.clock()
            
            local normalizedAccel = math.clamp(avgAcceleration / MaxAcceleration, 0, 1)
            State.AccelerationBoost = 1.0 + (normalizedAccel * ReactionBoost)
        else
            if os.clock() - State.LastAccelerationTime > 1.0 then
                State.IsAccelerated = false
                State.AccelerationBoost = 1.0
            end
        end
        
        return avgAcceleration
    end
    
    return 0
end

-- OPTIMIZED CURVE DETECTION
local function DetectBackwardCurve(velocityVec, currentPos, playerPos)
    if not Config.AntiCurveMode then return false, 0, Vector3.new(0, 0, 0) end
    
    State.TrajectoryHistory = State.TrajectoryHistory or {}
    if #State.TrajectoryHistory < 8 then return false, 0, Vector3.new(0, 0, 0) end
    
    local ballToPlayer = (playerPos - currentPos).Unit
    local velocityDir = velocityVec.Unit
    
    local dotProduct = ballToPlayer:Dot(velocityDir)
    
    if dotProduct < -0.2 then
        local recentFrames = {}
        local frameCount = math.min(10, #State.TrajectoryHistory)
        
        for i = #State.TrajectoryHistory - frameCount + 1, #State.TrajectoryHistory do
            if i > 0 then
                table.insert(recentFrames, State.TrajectoryHistory[i])
            end
        end
        
        if #recentFrames < 5 then return false, 0, Vector3.new(0, 0, 0) end
        
        local earlyToPlayer = (playerPos - recentFrames[1].position).Unit
        local earlyDir = recentFrames[1].direction
        local earlyDot = earlyToPlayer:Dot(earlyDir)
        
        local lateToPlayer = (playerPos - recentFrames[#recentFrames].position).Unit
        local lateDir = recentFrames[#recentFrames].direction
        local lateDot = lateToPlayer:Dot(lateDir)
        
        if earlyDot > 0.3 and dotProduct < -0.2 then
            State.BackwardCurveDetected = true
            
            local curveStrength = math.abs(dotProduct) * 30
            
            local perpendicular = ballToPlayer:Cross(velocityDir).Unit
            local compensation = (ballToPlayer * BACKWARD_CURVE_FACTOR) + (perpendicular * 0.8)
            
            return true, curveStrength, compensation * curveStrength
        end
    end
    
    State.BackwardCurveDetected = false
    return false, 0, Vector3.new(0, 0, 0)
end

local function DetectVerticalCurve(velocityVec, currentPos, playerPos)
    if not Config.AntiCurveMode then return false, 0, Vector3.new(0, 0, 0) end
    
    State.TrajectoryHistory = State.TrajectoryHistory or {}
    if #State.TrajectoryHistory < 6 then return false, 0, Vector3.new(0, 0, 0) end
    
    local verticalVelocity = velocityVec.Y
    local heightDiff = currentPos.Y - playerPos.Y
    
    if verticalVelocity > 20 and heightDiff > 5 then
        local recentFrames = {}
        local frameCount = math.min(10, #State.TrajectoryHistory)
        
        for i = #State.TrajectoryHistory - frameCount + 1, #State.TrajectoryHistory do
            if i > 0 then
                table.insert(recentFrames, State.TrajectoryHistory[i])
            end
        end
        
        local verticalAcceleration = 0
        for i = 2, #recentFrames do
            verticalAcceleration = verticalAcceleration + (recentFrames[i].velocity.Y - recentFrames[i-1].velocity.Y)
        end
        verticalAcceleration = verticalAcceleration / math.max(1, #recentFrames - 1)
        
        if verticalAcceleration > 6 then
            State.UpwardCurveDetected = true
            local curveStrength = math.min(25, verticalVelocity * 0.5 + math.abs(verticalAcceleration) * 2)
            
            local compensation = Vector3.new(0, -VERTICAL_CURVE_FACTOR, 0) * curveStrength
            
            return true, curveStrength, compensation
        end
    end
    
    if verticalVelocity < -20 and heightDiff < -5 then
        local recentFrames = {}
        local frameCount = math.min(10, #State.TrajectoryHistory)
        
        for i = #State.TrajectoryHistory - frameCount + 1, #State.TrajectoryHistory do
            if i > 0 then
                table.insert(recentFrames, State.TrajectoryHistory[i])
            end
        end
        
        local verticalAcceleration = 0
        for i = 2, #recentFrames do
            verticalAcceleration = verticalAcceleration + (recentFrames[i].velocity.Y - recentFrames[i-1].velocity.Y)
        end
        verticalAcceleration = verticalAcceleration / math.max(1, #recentFrames - 1)
        
        if verticalAcceleration < -6 then
            State.DownwardCurveDetected = true
            local curveStrength = math.min(25, math.abs(verticalVelocity) * 0.5 + math.abs(verticalAcceleration) * 2)
            
            local compensation = Vector3.new(0, VERTICAL_CURVE_FACTOR * 0.8, 0) * curveStrength
            
            return true, curveStrength, compensation
        end
    end
    
    State.UpwardCurveDetected = false
    State.DownwardCurveDetected = false
    return false, 0, Vector3.new(0, 0, 0)
end

local function DetectHorizontalCurve(velocityVec, currentPos, playerPos)
    if not Config.AntiCurveMode then return false, 0, Vector3.new(0, 0, 0) end
    
    State.TrajectoryHistory = State.TrajectoryHistory or {}
    if #State.TrajectoryHistory < 8 then return false, 0, Vector3.new(0, 0, 0) end
    
    local playerToBall = (currentPos - playerPos)
    local horizontalToPlayer = Vector3.new(playerToBall.X, 0, playerToBall.Z).Unit
    local horizontalVelocity = Vector3.new(velocityVec.X, 0, velocityVec.Z).Unit
    
    local recentFrames = {}
    local frameCount = math.min(12, #State.TrajectoryHistory)
    
    for i = #State.TrajectoryHistory - frameCount + 1, #State.TrajectoryHistory do
        if i > 0 then
            table.insert(recentFrames, State.TrajectoryHistory[i])
        end
    end
    
    if #recentFrames < 5 then return false, 0, Vector3.new(0, 0, 0) end
    
    local angularChanges = {}
    for i = 2, #recentFrames do
        local prevDir = Vector3.new(recentFrames[i-1].direction.X, 0, recentFrames[i-1].direction.Z).Unit
        local currDir = Vector3.new(recentFrames[i].direction.X, 0, recentFrames[i].direction.Z).Unit
        local angle = math.deg(math.acos(math.clamp(prevDir:Dot(currDir), -1, 1)))
        table.insert(angularChanges, angle)
    end
    
    local avgAngularChange = 0
    for _, angle in ipairs(angularChanges) do
        avgAngularChange = avgAngularChange + angle
    end
    avgAngularChange = avgAngularChange / math.max(1, #angularChanges)
    
    if avgAngularChange > 10 then
        local cross = horizontalToPlayer:Cross(horizontalVelocity)
        
        local curveStrength = math.min(20, avgAngularChange * 1.2)
        State.HorizontalCurveStrength = curveStrength
        
        if cross.Y > 0 then
            State.LeftCurveDetected = true
            State.RightCurveDetected = false
            
            local compensation = Vector3.new(horizontalVelocity.Z, 0, -horizontalVelocity.X) * HORIZONTAL_CURVE_FACTOR * curveStrength
            
            return true, curveStrength, compensation
        else
            State.LeftCurveDetected = false
            State.RightCurveDetected = true
            
            local compensation = Vector3.new(-horizontalVelocity.Z, 0, horizontalVelocity.X) * HORIZONTAL_CURVE_FACTOR * curveStrength
            
            return true, curveStrength, compensation
        end
    end
    
    State.LeftCurveDetected = false
    State.RightCurveDetected = false
    return false, 0, Vector3.new(0, 0, 0)
end

local function EnhancedCurveDetection(velocityVec, currentPos, playerPos)
    local totalCompensation = Vector3.new(0, 0, 0)
    local totalCurveStrength = 0
    local detectedCurves = {}
    
    local backwardDetected, backwardStrength, backwardComp = DetectBackwardCurve(velocityVec, currentPos, playerPos)
    if backwardDetected then
        totalCompensation = totalCompensation + backwardComp
        totalCurveStrength = totalCurveStrength + backwardStrength
        table.insert(detectedCurves, "Backward")
    end
    
    local verticalDetected, verticalStrength, verticalComp = DetectVerticalCurve(velocityVec, currentPos, playerPos)
    if verticalDetected then
        totalCompensation = totalCompensation + verticalComp
        totalCurveStrength = totalCurveStrength + verticalStrength
        if State.UpwardCurveDetected then
            table.insert(detectedCurves, "Upward")
        else
            table.insert(detectedCurves, "Downward")
        end
    end
    
    local horizontalDetected, horizontalStrength, horizontalComp = DetectHorizontalCurve(velocityVec, currentPos, playerPos)
    if horizontalDetected then
        totalCompensation = totalCompensation + horizontalComp
        totalCurveStrength = totalCurveStrength + horizontalStrength
        if State.LeftCurveDetected then
            table.insert(detectedCurves, "Left")
        else
            table.insert(detectedCurves, "Right")
        end
    end
    
    if totalCompensation.Magnitude > 0.1 then
        State.CurveDirectionVector = totalCompensation.Unit
    end
    
    return detectedCurves, totalCurveStrength, totalCompensation
end

-- OPTIMIZED TIMING ANALYSIS
local function TrackDirectionChanges(velocityVec, currentPos)
    local direction = velocityVec.Unit
    State.DirectionHistory = State.DirectionHistory or {}
    table.insert(State.DirectionHistory, {
        direction = direction,
        position = currentPos,
        time = os.clock()
    })
    
    while #State.DirectionHistory > 15 do
        table.remove(State.DirectionHistory, 1)
    end
    
    if #State.DirectionHistory < 3 then return 0, false end
    
    local totalAngleChange = 0
    local significantChanges = 0
    
    for i = 2, #State.DirectionHistory do
        local prev = State.DirectionHistory[i-1].direction
        local curr = State.DirectionHistory[i].direction
        local angle = math.deg(math.acos(math.clamp(prev:Dot(curr), -1, 1)))
        
        totalAngleChange = totalAngleChange + angle
        
        if angle > DirectionChangeThreshold then
            significantChanges = significantChanges + 1
        end
    end
    
    local avgAngleChange = totalAngleChange / math.max(1, #State.DirectionHistory - 1)
    
    local isCurveRecoveryPattern = false
    if #State.DirectionHistory >= 6 then
        local middleIdx = math.floor(#State.DirectionHistory / 2)
        local earlyDirs = {}
        local lateDirs = {}
        
        for i = 1, middleIdx do
            table.insert(earlyDirs, State.DirectionHistory[i].direction)
        end
        
        for i = middleIdx + 1, #State.DirectionHistory do
            table.insert(lateDirs, State.DirectionHistory[i].direction)
        end
        
        local avgEarlyDir = Vector3.new(0, 0, 0)
        for _, dir in ipairs(earlyDirs) do
            avgEarlyDir = avgEarlyDir + dir
        end
        avgEarlyDir = (avgEarlyDir / #earlyDirs).Unit
        
        local avgLateDir = Vector3.new(0, 0, 0)
        for _, dir in ipairs(lateDirs) do
            avgLateDir = avgLateDir + dir
        end
        avgLateDir = (avgLateDir / #lateDirs).Unit
        
        local playerPos = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and LocalPlayer.Character.PrimaryPart.Position
        if not playerPos then return avgAngleChange, false end
        
        local toPlayerEarly = (playerPos - State.DirectionHistory[1].position).Unit
        local toPlayerLate = (playerPos - State.DirectionHistory[#State.DirectionHistory].position).Unit
        
        local earlyDot = avgEarlyDir:Dot(toPlayerEarly)
        local lateDot = avgLateDir:Dot(toPlayerLate)
        
        if earlyDot < 0.2 and lateDot > 0.6 then
            isCurveRecoveryPattern = true
            if not State.IsCurveRecovery then
                State.IsCurveRecovery = true
                State.CurveRecoveryStart = os.clock()
            end
        end
    end
    
    if State.IsCurveRecovery and (os.clock() - State.CurveRecoveryStart) > CurveRecoveryTime then
        State.IsCurveRecovery = false
    end
    
    return avgAngleChange, isCurveRecoveryPattern
end

-- OPTIMIZED TRAJECTORY ANALYSIS
local function ThreeSixtyTrajectoryAnalysis(currentPos, velocityVec)
    State.TrajectoryHistory = State.TrajectoryHistory or {}
    local trajectoryData = {
        position = currentPos,
        velocity = velocityVec,
        time = os.clock(),
        direction = velocityVec.Unit,
        magnitude = velocityVec.Magnitude
    }
    
    table.insert(State.TrajectoryHistory, trajectoryData)
    
    while #State.TrajectoryHistory > 30 do
        table.remove(State.TrajectoryHistory, 1)
    end
    
    if #State.TrajectoryHistory < 8 then 
        return 0, Vector3.new(0, 0, 0), "None" 
    end
    
    local playerChar = LocalPlayer.Character
    local playerRoot = playerChar and playerChar.PrimaryPart
    if not playerRoot then return 0, Vector3.new(0, 0, 0), "None" end
    local playerPos = playerRoot.Position
    
    local detectedCurves, curveStrength, curveCompensation = EnhancedCurveDetection(velocityVec, currentPos, playerPos)
    
    if #detectedCurves > 0 then
        local curveType = table.concat(detectedCurves, "+")
        
        if State.IsAccelerated then
            curveStrength = curveStrength * State.AccelerationBoost
            curveCompensation = curveCompensation * State.AccelerationBoost
        end
        
        return curveStrength, curveCompensation, curveType
    end
    
    return 0, Vector3.new(0, 0, 0), "None"
end

-- OPTIMIZED VECTOR ANALYSIS
local function TripleVectorAnalysis(currentPos, velocityVec, dt)
    State.TripleVectorHistory = State.TripleVectorHistory or {}
    table.insert(State.TripleVectorHistory, {
        pos = currentPos,
        vel = velocityVec,
        time = os.clock()
    })
    
    while #State.TripleVectorHistory > 15 do
        table.remove(State.TripleVectorHistory, 1)
    end
    
    if #State.TripleVectorHistory < 6 then return 95, Vector3.new(0, 0, 0) end
    
    local playerChar = LocalPlayer.Character
    local playerRoot = playerChar and playerChar.PrimaryPart
    if not playerRoot then return 95, Vector3.new(0, 0, 0) end
    local rootPos = playerRoot.Position
    
    local confidenceScores = {}
    local totalJerk = 0
    
    for i = 3, #State.TripleVectorHistory do
        local past = State.TripleVectorHistory[i-2]
        local present = State.TripleVectorHistory[i-1]
        local future = State.TripleVectorHistory[i]
        
        local vel1 = (present.pos - past.pos) / math.max(0.001, present.time - past.time)
        local vel2 = (future.pos - present.pos) / math.max(0.001, future.time - present.time)
        
        local accel = (vel2 - vel1)
        totalJerk = totalJerk + accel.Magnitude
        
        local timeToPlayer = (rootPos - future.pos).Magnitude / math.max(1, vel2.Magnitude)
        local predictedPos = future.pos + (vel2 * timeToPlayer)
        local missDistance = (predictedPos - rootPos).Magnitude
        
        local accuracyScore = math.max(25, 100 - (missDistance * 1.5))
        table.insert(confidenceScores, accuracyScore)
    end
    
    State.JerkLevel = totalJerk / #State.TripleVectorHistory
    
    local totalConfidence = 0
    for _, score in ipairs(confidenceScores) do
        totalConfidence = totalConfidence + score
    end
    local perfectConfidence = totalConfidence / math.max(1, #confidenceScores)
    
    local quantumPrediction = Vector3.new(0, 0, 0)
    if #State.TripleVectorHistory >= 5 then
        local latest = State.TripleVectorHistory[#State.TripleVectorHistory]
        local mid = State.TripleVectorHistory[#State.TripleVectorHistory - 2]
        local old = State.TripleVectorHistory[#State.TripleVectorHistory - 4]
        
        local accel = (latest.vel - mid.vel) / math.max(0.001, latest.time - mid.time)
        local jerk = (mid.vel - old.vel) / math.max(0.001, mid.time - old.time)
        
        quantumPrediction = accel * 1.2 + (jerk * 0.5)
    end
    
    return perfectConfidence, quantumPrediction
end

-- OPTIMIZED SKILL DETECTION
local function PerfectSkillDetection()
    if not State.VelocityHistory or #State.VelocityHistory < 6 then return false, 0 end
    
    local velocities = State.VelocityHistory
    local len = #velocities
    
    local decelPattern = velocities[len-3] > 60 and velocities[len-2] < 25 and velocities[len-1] < 20 and velocities[len] > 70
    local spikePattern = velocities[len] > (velocities[len-1] * 3) and velocities[len] > 90
    
    local accelerationPattern = false
    if len >= 4 then
        local accel1 = velocities[len-2] - velocities[len-3]
        local accel2 = velocities[len-1] - velocities[len-2]
        local accel3 = velocities[len] - velocities[len-1]
        
        accelerationPattern = accel1 > 20 and accel2 > 20 and accel3 > 20
        
        if not accelerationPattern then
            local totalAcceleration = accel1 + accel2 + accel3
            accelerationPattern = totalAcceleration > 80 and velocities[len] > 60
        end
    end
    
    local sustainedPattern = true
    for i = len-3, len do
        if i > 0 and velocities[i] - velocities[i-1] < 12 then
            sustainedPattern = false
            break
        end
    end
    sustainedPattern = sustainedPattern and velocities[len] > 85
    
    if decelPattern or spikePattern or accelerationPattern or sustainedPattern then
        State.IsSkillActive = true
        local bonus = 5.5
        
        if accelerationPattern then
            bonus = bonus + 2.0
        end
        
        return true, bonus
    end
    
    State.IsSkillActive = false
    return false, 0
end

-- OPTIMIZED COMPENSATION CALCULATION
local function ZeroMissCompensation(velocityMag, ping, isSkill, skillBonus, curveStrength, confidence)
    local pingMs = ping * 1000
    local serverBuffer = 0.05
    
    local totalLatency = ping + serverBuffer + State.PingCompensation
    local baseDistance = 16  -- Reduced from 18
    
    if isSkill then baseDistance = baseDistance + skillBonus end
    
    if State.JerkLevel > 50 then
        baseDistance = baseDistance + (State.JerkLevel * 0.05)
    end
    
    if curveStrength > 0 and Config.AntiCurveMode then
        local curveBonus = curveStrength * CURVE_STRENGTH_MULTIPLIER
        
        if State.BackwardCurveDetected then
            curveBonus = curveBonus * BACKWARD_CURVE_FACTOR
        elseif State.UpwardCurveDetected or State.DownwardCurveDetected then
            curveBonus = curveBonus * VERTICAL_CURVE_FACTOR
        elseif State.LeftCurveDetected or State.RightCurveDetected then
            curveBonus = curveBonus * HORIZONTAL_CURVE_FACTOR
        end
        
        if State.IsAccelerated then
            curveBonus = curveBonus * State.AccelerationBoost
        end
        
        if State.IsCurveRecovery then
            curveBonus = curveBonus * 1.2
        end
        
        baseDistance = baseDistance + curveBonus
    end
    
    if State.IsAccelerated then
        local accelBoost = (State.AccelerationBoost - 1.0) * 20
        baseDistance = baseDistance + accelBoost
    end
    
    if confidence < 45 then baseDistance = baseDistance * 0.88
    elseif confidence > 90 then baseDistance = baseDistance * 1.1
    end
    
    if State.CloseCombatActive then
        baseDistance = baseDistance * 0.7
    end
    
    if State.UltraCloseMode then
        baseDistance = baseDistance * 0.5
    end
    
    local velocityMultiplier = 1.2
    if velocityMag > 300 then velocityMultiplier = 3.2  -- Reduced
    elseif velocityMag > 250 then velocityMultiplier = 2.8
    elseif velocityMag > 200 then velocityMultiplier = 2.5
    elseif velocityMag > 170 then velocityMultiplier = 2.2
    elseif velocityMag > 140 then velocityMultiplier = 1.9
    elseif velocityMag > 110 then velocityMultiplier = 1.7
    elseif velocityMag > 80 then velocityMultiplier = 1.5
    end
    
    if State.IsAccelerated then
        velocityMultiplier = velocityMultiplier * State.AccelerationBoost
    end
    
    if State.IsCurveRecovery then
        velocityMultiplier = velocityMultiplier * 1.1
    end
    
    baseDistance = baseDistance + (totalLatency * velocityMag * velocityMultiplier * ADAPTIVE_TIMING_FACTOR)
    
    local pingVariance, _ = GetPingVariance()
    local varianceMs = pingVariance * 1000
    
    if varianceMs > 50 then
        baseDistance = baseDistance + (varianceMs * 0.1)
    end
    
    if pingMs >= 300 then baseDistance = baseDistance * 1.2
    elseif pingMs >= 200 then baseDistance = baseDistance * 1.12
    elseif pingMs >= 150 then baseDistance = baseDistance * 1.06
    elseif pingMs < 50 then baseDistance = baseDistance * 0.94
    end
    
    local accuracyMultiplier = Config.AccuracyBoost / 100
    baseDistance = baseDistance * accuracyMultiplier
    
    baseDistance = baseDistance + Config.ManualOffset
    
    -- Apply optimal timing offset
    baseDistance = baseDistance * (1 + State.OptimalParryOffset)
    
    return math.clamp(baseDistance, MinRange, MaxRange)
end

-- OPTIMIZED HITBOX VISUALIZER
local function UpdateHitboxVisualizer(position, radius)
    if not Config.ShowHitbox then
        if State.HitboxVisualizer then
            State.HitboxVisualizer:Destroy()
            State.HitboxVisualizer = nil
        end
        return
    end
    
    if not State.HitboxVisualizer or not State.HitboxVisualizer.Parent then
        State.HitboxVisualizer = Instance.new("Part")
        State.HitboxVisualizer.Name = "HitboxVisualizer"
        State.HitboxVisualizer.Anchored = true
        State.HitboxVisualizer.CanCollide = false
        State.HitboxVisualizer.Shape = Enum.PartType.Ball
        State.HitboxVisualizer.Material = Enum.Material.ForceField
        
        if State.BackwardCurveDetected then
            State.HitboxVisualizer.Color = Color3.fromRGB(255, 80, 80)
        elseif State.UpwardCurveDetected then
            State.HitboxVisualizer.Color = Color3.fromRGB(80, 255, 80)
        elseif State.DownwardCurveDetected then
            State.HitboxVisualizer.Color = Color3.fromRGB(80, 80, 255)
        elseif State.LeftCurveDetected or State.RightCurveDetected then
            State.HitboxVisualizer.Color = Color3.fromRGB(255, 255, 80)
        elseif State.IsAccelerated then
            State.HitboxVisualizer.Color = Color3.fromRGB(255, 40, 40)
        else
            State.HitboxVisualizer.Color = Color3.fromRGB(255, 160, 0)
        end
        
        State.HitboxVisualizer.Transparency = 0.65
        State.HitboxVisualizer.CastShadow = false
        State.HitboxVisualizer.Parent = workspace
        
        local highlight = Instance.new("Highlight")
        highlight.FillColor = State.HitboxVisualizer.Color
        highlight.FillTransparency = 0.75
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.OutlineTransparency = 0.4
        highlight.Parent = State.HitboxVisualizer
    end
    
    local diameter = radius * 2
    local targetSize = Vector3.new(diameter, diameter, diameter)
    State.HitboxVisualizer.Size = State.HitboxVisualizer.Size:Lerp(targetSize, 0.4)
    State.HitboxVisualizer.Position = position
    
    if State.BackwardCurveDetected then
        State.HitboxVisualizer.Color = Color3.fromRGB(255, 80, 80)
    elseif State.UpwardCurveDetected then
        State.HitboxVisualizer.Color = Color3.fromRGB(80, 255, 80)
    elseif State.DownwardCurveDetected then
        State.HitboxVisualizer.Color = Color3.fromRGB(80, 80, 255)
    elseif State.LeftCurveDetected or State.RightCurveDetected then
        State.HitboxVisualizer.Color = Color3.fromRGB(255, 255, 80)
    elseif State.IsAccelerated then
        State.HitboxVisualizer.Color = Color3.fromRGB(255, 40, 40)
    else
        State.HitboxVisualizer.Color = Color3.fromRGB(255, 160, 0)
    end
    
    if State.HitboxVisualizer:FindFirstChild("Highlight") then
        State.HitboxVisualizer.Highlight.FillColor = State.HitboxVisualizer.Color
    end
end

-- OPTIMIZED TARGETING ALGORITHM
local function ZeroMissTargeting(currentPos, velocityVec, rootPos)
    if not rootPos then return false end
    
    local color = GetBallColor(State.BallObject)
    if color == Color3.new(1, 1, 1) then return false end
    
    local velocityMag = velocityVec.Magnitude
    local distance = (rootPos - currentPos).Magnitude
    
    State.CloseCombatActive = (distance < CloseCombatThreshold and velocityMag > 40)
    State.UltraCloseMode = (distance < MinRange * 1.5 and velocityMag > 20)
    
    local dirToPlayer = (rootPos - currentPos).Unit
    local dirOfBall = velocityVec.Unit
    local dotProduct = dirToPlayer:Dot(dirOfBall)
    
    local avgAngleChange, isCurveRecovery = TrackDirectionChanges(velocityVec, currentPos)
    
    -- Detect pass-by and curve-back scenarios (ALWAYS ACTIVE)
    local isPassBy, minPassByDistance, curveBackConfidence = DetectPassByScenario(currentPos, velocityVec, rootPos)
    State.CurveBackDetected = curveBackConfidence > 0.6
    State.CurveBackConfidence = curveBackConfidence
    
    if State.IsCurveRecovery or isCurveRecovery then
        if dotProduct > 0.2 and velocityMag > 30 then
            State.ConsecutiveDetections = math.min(State.ConsecutiveDetections + 3, 10)
        end
    end
    
    -- SPECIAL HANDLING FOR CURVE-BACK SCENARIOS
    if State.CurveBackDetected then
        State.ConsecutiveDetections = math.min(State.ConsecutiveDetections + 6, 12)
    end
    
    local dynamicPanicRange = 25
    if velocityMag > 200 then dynamicPanicRange = 35 end
    if State.IsAccelerated then dynamicPanicRange = dynamicPanicRange * State.AccelerationBoost end
    if State.BackwardCurveDetected then dynamicPanicRange = dynamicPanicRange * 1.2 end
    if State.CurveBackDetected then dynamicPanicRange = dynamicPanicRange * 1.4 end
    
    if State.UltraCloseMode and dotProduct > 0.15 then
        return true
    end
    
    -- SPECIAL: Allow detection for curve-back even at larger distances
    if State.CurveBackDetected and distance < dynamicPanicRange * 1.8 and velocityMag > 30 and dotProduct > 0.15 then
        return true
    end
    
    if (State.IsCurveRecovery or isCurveRecovery) and distance < dynamicPanicRange * 1.5 and velocityMag > 40 and dotProduct > 0.2 then
        return true
    end
    
    if distance < dynamicPanicRange and velocityMag > 40 and dotProduct > 0.25 then
        return true
    end
    
    local perfectConfidence, quantumPrediction = TripleVectorAnalysis(currentPos, velocityVec, 0.016)
    State.PerfectConfidence = perfectConfidence
    State.QuantumPrediction = quantumPrediction
    
    if perfectConfidence < 25 and not State.CurveBackDetected then
        State.ConsecutiveDetections = 0
        return false
    end
    
    local toPlayer = rootPos - currentPos
    local distAlongPath = toPlayer:Dot(velocityVec.Unit)
    local isMovingTowards = distAlongPath > 0
    
    if isMovingTowards then
        local closestPointOnPath = currentPos + (velocityVec.Unit * distAlongPath)
        local perpendicularDist = (closestPointOnPath - rootPos).Magnitude
        
        local maxPerpendicularDist = 16
        if State.IsCurveRecovery then
            maxPerpendicularDist = 24
        end
        if State.BackwardCurveDetected then
            maxPerpendicularDist = 28
        end
        if State.CurveBackDetected then
            maxPerpendicularDist = 35
        end
        
        if perpendicularDist < maxPerpendicularDist then
            local timeToClosest = distAlongPath / velocityMag
            
            local detectionThreshold = 0.6
            if State.IsAccelerated then
                detectionThreshold = 0.45 / State.AccelerationBoost
            end
            if State.IsCurveRecovery then
                detectionThreshold = 0.75
            end
            if State.BackwardCurveDetected then
                detectionThreshold = 0.65
            end
            if State.CurveBackDetected then
                detectionThreshold = 0.9
            end
            
            if timeToClosest < detectionThreshold then
                State.ConsecutiveDetections = State.ConsecutiveDetections + 2
            end
        end
    end
    
    local timeToImpact = distance / math.max(1, velocityMag)
    local predictedPos = currentPos + (velocityVec * timeToImpact)
    
    local accelerationFactor = quantumPrediction * 0.5 * (timeToImpact * timeToImpact)
    predictedPos = predictedPos + accelerationFactor
    
    local quantumMultiplier = 3.5
    if velocityMag > 180 then quantumMultiplier = 3.2
    elseif velocityMag > 140 then quantumMultiplier = 2.8
    end
    
    if State.IsAccelerated then
        quantumMultiplier = quantumMultiplier * State.AccelerationBoost
    end
    
    if State.IsCurveRecovery then
        quantumMultiplier = quantumMultiplier * 1.15
    end
    
    predictedPos = predictedPos + (quantumPrediction * timeToImpact * quantumMultiplier)
    
    local curveStrength, curveOffset, curveType = ThreeSixtyTrajectoryAnalysis(currentPos, velocityVec)
    State.CurveStrength = curveStrength
    State.CurveType = curveType
    
    if curveStrength > 0 then
        local curveMultiplier = 1.0
        
        if State.BackwardCurveDetected then
            curveMultiplier = BACKWARD_CURVE_FACTOR
        elseif State.UpwardCurveDetected or State.DownwardCurveDetected then
            curveMultiplier = VERTICAL_CURVE_FACTOR
        elseif State.LeftCurveDetected or State.RightCurveDetected then
            curveMultiplier = HORIZONTAL_CURVE_FACTOR
        end
        
        if State.IsAccelerated then
            curveMultiplier = curveMultiplier * State.AccelerationBoost
        end
        if State.IsCurveRecovery then
            curveMultiplier = curveMultiplier * 1.2
        end
        if State.CurveBackDetected then
            curveMultiplier = curveMultiplier * 1.4
        end
        
        local timeFactor = math.min(1.0, timeToImpact * 2)
        predictedPos = predictedPos + (curveOffset * timeFactor * curveMultiplier)
    end
    
    local missMargin = (predictedPos - rootPos).Magnitude
    
    local maxMiss = 20 + (State.CurveStrength * 5)
    if perfectConfidence > 85 then maxMiss = maxMiss + 6 end
    if State.BackwardCurveDetected then maxMiss = maxMiss + 22 end
    if State.IsCurveRecovery then maxMiss = maxMiss + 15 end
    if State.IsAccelerated then maxMiss = maxMiss * State.AccelerationBoost end
    if velocityMag > 250 then maxMiss = maxMiss + 12 end
    if State.CurveBackDetected then maxMiss = maxMiss + 20 end
    
    if missMargin > maxMiss and distance > 30 and not State.CurveBackDetected then
        if State.ConsecutiveDetections > 0 then
            State.ConsecutiveDetections = State.ConsecutiveDetections - 1
        end
        return false
    end
    
    if State.BackwardCurveDetected then
        if distance < 60 then return true end
    end
    
    if State.CurveBackDetected then
        if distance < 45 then return true end
    end
    
    local angleTolerance = 0.6
    if State.CurveStrength > 5 then angleTolerance = 0.45 end
    if velocityMag > 180 then angleTolerance = angleTolerance - 0.06 end
    if State.IsCurveRecovery then angleTolerance = 0.7 end
    if State.IsAccelerated then angleTolerance = angleTolerance + 0.1 end
    if velocityMag > 250 then angleTolerance = 0.4 end
    if State.CurveBackDetected then angleTolerance = 0.35 end
    
    if dotProduct < angleTolerance and not isMovingTowards and not State.CurveBackDetected then
        State.ConsecutiveDetections = 0
        return false
    end
    
    if distance > MaxRange then
        State.ConsecutiveDetections = 0
        return false
    end
    
    local heightDiff = math.abs(currentPos.Y - rootPos.Y)
    if heightDiff > 30 then
        State.ConsecutiveDetections = 0
        return false
    end
    
    local detectionThreshold = 0.5
    if State.IsCurveRecovery then
        detectionThreshold = 0.35
    end
    if State.CurveBackDetected then
        detectionThreshold = 0.25
    end
    
    if dotProduct > detectionThreshold then
        State.ConsecutiveDetections = State.ConsecutiveDetections + 2
    end
    
    local requiredDetections = 3
    if State.IsCurveRecovery then
        requiredDetections = 2
    end
    if State.BackwardCurveDetected then
        requiredDetections = 2
    end
    if State.CurveBackDetected then
        requiredDetections = 2
    end
    
    return State.ConsecutiveDetections >= requiredDetections
end

-- OPTIMIZED PARRY FUNCTION WITH BETTER TIMING
local function TriggerParry()
    if State.IsCurving then return end
    
    local currentTime = os.clock()
    local timeSinceLastParry = currentTime - State.LastParry
    
    local velocityMag = State.PreviousVelocity and State.PreviousVelocity.Magnitude or 0
    
    -- Use smart cooldown calculation
    local minCooldown = CalculateSmartCooldown(velocityMag, State.CurveBackDetected, State.CurveBackConfidence or 0)
    
    -- Check if we should override cooldown for curve-back scenario
    local shouldParry = true
    if timeSinceLastParry < minCooldown then
        -- Allow parry even with short cooldown if it's a strong curve-back scenario
        if State.CurveBackDetected and State.CurveBackConfidence > 0.7 then
            local curveBackCooldown = minCooldown * 0.3
            if timeSinceLastParry < curveBackCooldown then
                shouldParry = false
            end
        else
            shouldParry = false
        end
    end
    
    if not shouldParry then return end

    if Config.Debug then
        local cooldownType = State.CurveBackDetected and "CURVE-BACK" or "NORMAL"
        print(string.format("[V14.6 OPTIMIZED] PARRY! Speed:%.1f | Cooldown:%.5f | Type: %s | Timing Offset: %.3f", 
            velocityMag, minCooldown, cooldownType, State.OptimalParryOffset or 0))
    end

    State.IsCurving = true
    State.TotalAttempts = State.TotalAttempts + 1
    local originalCFrame = Camera.CFrame
    
    local curveDirection = nil
    if Config.AutoCurve then
        local curveMode = Config.CurveMode
        if curveMode == "Random" then
            local randomModes = {"Up", "Down", "Back", "Left", "Right"}
            curveMode = randomModes[math.random(1, #randomModes)]
        end
        
        local rad90 = math.rad(90)
        if curveMode == "Up" then curveDirection = CFrame.Angles(rad90, 0, 0)
        elseif curveMode == "Down" then curveDirection = CFrame.Angles(-rad90, 0, 0)
        elseif curveMode == "Back" then curveDirection = CFrame.Angles(0, math.rad(180), 0)
        elseif curveMode == "Left" then curveDirection = CFrame.Angles(0, rad90, 0)
        elseif curveMode == "Right" then curveDirection = CFrame.Angles(0, -rad90, 0)
        end
    end
    
    if Config.AutoCurve and curveDirection then
        if Config.InvisibleCurve then
            Camera.CFrame = originalCFrame * curveDirection
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            task.wait()
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
            Camera.CFrame = originalCFrame
        else
            Camera.CFrame = originalCFrame * curveDirection
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
            
            local recoveryTime = 0.04  -- Reduced from 0.045
            if State.IsAccelerated then
                recoveryTime = recoveryTime * (0.85 / State.AccelerationBoost)
            end
            
            task.delay(recoveryTime, function() Camera.CFrame = originalCFrame end)
        end
    else
        if IS_MOBILE then
            local parryButton = PlayerGui:FindFirstChild("Parry", true) or PlayerGui:FindFirstChild("ParryButton", true) or PlayerGui:FindFirstChild("BlockButton", true)
            if parryButton and parryButton:IsA("GuiButton") then
                for _, connection in pairs(getconnections(parryButton.MouseButton1Click)) do connection:Fire() end
            else
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
            end
        else
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        end
    end
    
    State.LastParry = currentTime
    State.SuccessfulParries = State.SuccessfulParries + 1
    
    -- Track timing success (we'll update this based on actual hit detection)
    local timingSuccess = true  -- We'll assume success for now
    TrackParryAttempt(timingSuccess, State.OptimalParryOffset)
    
    local resetTime = 0.04  -- Reduced from 0.045
    if State.IsAccelerated then
        resetTime = resetTime * (0.85 / State.AccelerationBoost)
    end
    
    task.delay(resetTime, function() State.IsCurving = false end)
    
    -- Reset curve-back detection after parry attempt
    if State.CurveBackDetected then
        State.CurveBackDetected = false
        State.CurveBackConfidence = 0
        State.MissedOpportunities = 0
    end
end

-- OPTIMIZED SPAM PARRY
local function ExtremeSpamParry()
    local ping = LocalPlayer:GetNetworkPing()
    local pingMs = ping * 1000
    local velocityMag = State.PreviousVelocity and State.PreviousVelocity.Magnitude or 0
    
    local cooldowns = {Low = 0.01, Medium = 0.005, High = 0.0012, Extreme = 0.0001}  -- Reduced
    
    if pingMs >= 220 then
        cooldowns.Low = 0.008; cooldowns.Medium = 0.004; cooldowns.High = 0.001; cooldowns.Extreme = 0.0006
    end
    
    if velocityMag > 180 then
        cooldowns.Extreme = 0.0003; cooldowns.High = 0.0007
    end
    
    if State.IsAccelerated then
        cooldowns.Extreme = 0.00004
        cooldowns.High = 0.0005
        cooldowns.Medium = 0.0025
        cooldowns.Low = 0.005
    end
    
    if State.CloseCombatActive then
        cooldowns.Low = 0.004
        cooldowns.Medium = 0.002
        cooldowns.High = 0.0006
        cooldowns.Extreme = 0.00004
    end
    
    if State.UltraCloseMode then
        cooldowns.Extreme = 0.000001
        cooldowns.High = 0.0003
    end
    
    -- Reduce cooldown for curve-back scenarios
    if State.CurveBackDetected and State.CurveBackConfidence > 0.6 then
        cooldowns.Extreme = cooldowns.Extreme * 0.15
        cooldowns.High = cooldowns.High * 0.25
        cooldowns.Medium = cooldowns.Medium * 0.35
        cooldowns.Low = cooldowns.Low * 0.45
    end
    
    local cooldown = cooldowns[Config.SpamIntensity] or 0.00006
    
    if (os.clock() - State.LastParry) > cooldown then 
        TriggerParry()
        
        if Config.SpamIntensity == "Extreme" then
            task.spawn(function()
                task.wait(cooldown * 1.1)  -- Reduced from 1.2
                if Config.AutoSpam and (os.clock() - State.LastParry) > (cooldown * 1.5) then  -- Reduced from 1.8
                    TriggerParry()
                end
            end)
        end
    end
end

-- MANUAL SPAM LOOP
local function ManualSpamLoop()
    while Config.ManualSpam and task.wait(0.0015) do  -- Reduced from 0.0018
        local currentTime = os.clock()
        local timeSinceLast = currentTime - State.LastParry
        
        if timeSinceLast > 0.0012 then  -- Reduced from 0.0015
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            task.wait(0.0003)  -- Reduced from 0.0004
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
            State.LastParry = currentTime
            
            -- Add burst effect for better timing
            if math.random(1, 4) == 1 then
                task.wait(0.0006)  -- Reduced from 0.0008
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                task.wait(0.0002)  -- Reduced from 0.0003
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                State.LastParry = os.clock()
            end
        end
    end
    State.ManualSpamRunning = false
end

-- // 4. UI SETUP (SIMPLIFIED) //
local Window = Library:CreateWindow({ Title = "BURAT HUB" })
local MainTab = Window:CreateTab("Main")

MainTab:CreateSection("Combat")
MainTab:CreateToggle("Auto Parry", function(Value)
    Config.Enabled = Value
    if Value then
        print("[V14.6 OPTIMIZED] Auto Parry ENABLED - Optimized Timing & Curve-Back Detection Active")
    else
        State.VelocityHistory = {}
        State.PositionHistory = {}
        State.TripleVectorHistory = {}
        State.TrajectoryHistory = {}
        State.AccelerationHistory = {}
        State.DirectionHistory = {}
        State.PassByDistanceHistory = {}
        State.RecentParryAttempts = {}
        State.TimingHistory = {}
    end
    
    State.BallShadow = nil
    State.BallObject = nil
    State.PreviousPosition = nil
    State.PreviousVelocity = nil
    State.ConsecutiveDetections = 0
    State.SmoothedVelocity = Vector3.new(0, 0, 0)
    State.PerfectConfidence = 0
    State.SuccessfulParries = 0
    State.TotalAttempts = 0
    State.ManualSpamRunning = false
    State.CloseCombatActive = false
    State.UltraCloseMode = false
    State.IsAccelerated = false
    State.AccelerationBoost = 1.0
    State.IsCurveRecovery = false
    State.CurveRecoveryStart = 0
    State.BackwardCurveDetected = false
    State.UpwardCurveDetected = false
    State.DownwardCurveDetected = false
    State.LeftCurveDetected = false
    State.RightCurveDetected = false
    State.CurveBackDetected = false
    State.CurveBackConfidence = 0
    State.MissedOpportunities = 0
    State.AdaptiveCooldownMultiplier = 1.0
    State.CooldownOverrideActive = false
    State.OptimalParryOffset = 0
    
    if not Value and State.HitboxVisualizer then
        State.HitboxVisualizer:Destroy()
        State.HitboxVisualizer = nil
    end
end)

MainTab:CreateToggle("Auto Spam (Clash)", function(Value) 
    Config.AutoSpam = Value 
    if Value then
        print("[V14.6 OPTIMIZED] Extreme Auto Spam ENABLED - Optimized Timing")
    end
end)

MainTab:CreateButton("Spam: Extreme", function(Btn)
    local modes = {"Low", "Medium", "High", "Extreme"}
    local currentIndex = 1
    for i, mode in ipairs(modes) do
        if Config.SpamIntensity == mode then currentIndex = i break end
    end
    currentIndex = currentIndex + 1
    if currentIndex > #modes then currentIndex = 1 end
    Config.SpamIntensity = modes[currentIndex]
    Btn.Text = "Spam: " .. Config.SpamIntensity
    print("[V14.6 OPTIMIZED] Spam Intensity: " .. Config.SpamIntensity)
end)

MainTab:CreateSection("Curve Settings")
MainTab:CreateToggle("Anti Curve", function(Value) 
    Config.AntiCurveMode = Value 
    if Value then
        print("[V14.6 OPTIMIZED] Anti-Curve ENABLED")
    else
        print("[V14.6 OPTIMIZED] Anti-Curve DISABLED")
    end
end)

MainTab:CreateToggle("Auto Curve", function(Value) Config.AutoCurve = Value end)
MainTab:CreateToggle("Invisible Curve", function(Value) Config.InvisibleCurve = Value end)
MainTab:CreateButton("Curve Mode: ..", function(Btn)
    CurveIndex = CurveIndex + 1
    if CurveIndex > #CurveModes then CurveIndex = 1 end
    Config.CurveMode = CurveModes[CurveIndex]
    Btn.Text = "Curve Mode: " .. Config.CurveMode
end)

MainTab:CreateSection("Misc")
MainTab:CreateToggle("Show Hitbox", function(Value) 
    Config.ShowHitbox = Value
    if not Value and State.HitboxVisualizer then
        State.HitboxVisualizer:Destroy()
        State.HitboxVisualizer = nil
    end
end)
MainTab:CreateToggle("Debug Mode", function(Value) Config.Debug = Value end)

local VisualsTab = Window:CreateTab("Visuals")
VisualsTab:CreateSection("World")
VisualsTab:CreateSlider("Field Of View", 70, 120, 70, function(v) 
    Config.FOV = v
    workspace.CurrentCamera.FieldOfView = v 
end)

VisualsTab:CreateToggle("Max Camera Height", function(Value)
    Config.MaxCamera = Value
    if Value then
        LocalPlayer.CameraMaxZoomDistance = 9999
        LocalPlayer.CameraMinZoomDistance = 0.5
    else
        LocalPlayer.CameraMaxZoomDistance = 128
        LocalPlayer.CameraMinZoomDistance = 0.5
    end
end)

VisualsTab:CreateToggle("Anti-AFK", function(Value)
    Config.AntiAFK = Value
    if Value then
        getgenv()[ScriptKey].AFKLoop = task.spawn(function()
            local VirtualUser = game:GetService("VirtualUser")
            while Config.AntiAFK and task.wait(120) do
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end
        end)
    else
        if getgenv()[ScriptKey].AFKLoop then 
            task.cancel(getgenv()[ScriptKey].AFKLoop) 
        end
    end
end)

local SettingsTab = Window:CreateTab("Settings")
SettingsTab:CreateSection("Performance")

SettingsTab:CreateToggle("FPS Boost", function(Value)
    Config.AggressiveFPS = Value
    local Terrain = workspace:FindFirstChild("Terrain")
    
    if Value then
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 9e9
        if Terrain then
            Terrain.WaterWaveSize = 0
            Terrain.WaterReflectance = 0
            Terrain.WaterTransparency = 0
        end
        
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and not v.Parent:FindFirstChild("Humanoid") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
                v.CastShadow = false
            elseif v:IsA("Texture") or v:IsA("Decal") then
                v.Transparency = 1
            elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                v.Enabled = false
            end
        end
        
        for _, v in pairs(Lighting:GetChildren()) do
            if v:IsA("PostEffect") then v.Enabled = false end
        end
    else
        Lighting.GlobalShadows = true
        Lighting.FogEnd = 10000
        if Terrain then
            Terrain.WaterWaveSize = 0.15
            Terrain.WaterReflectance = 1
            Terrain.WaterTransparency = 1
        end
        
        for _, v in pairs(Lighting:GetChildren()) do
            if v:IsA("PostEffect") then v.Enabled = true end
        end
    end
end)

SettingsTab:CreateSection("Keybinds")

SettingsTab:CreateButton("Minimize Key: LeftCtrl [Click to Change]", function(Btn)
    if Config.IsListeningForKey then return end
    
    Config.IsListeningForKey = true
    Btn.Text = "Press Any Key..."
    Btn.BackgroundColor3 = THEME.Accent
    
    local connection
    connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Keyboard then
            Config.MinimizeKeybind = input.KeyCode
            
            local keyName = input.KeyCode.Name
            Btn.Text = "Minimize Key: " .. keyName .. " [Click to Change]"
            Btn.BackgroundColor3 = THEME.Section
            
            Config.IsListeningForKey = false
            connection:Disconnect()
        end
    end)
end)

SettingsTab:CreateButton("Manual Spam Key: V [Click to Change]", function(Btn)
    if Config.IsListeningForKey then return end
    
    Config.IsListeningForKey = true
    Btn.Text = "Press Any Key..."
    Btn.BackgroundColor3 = THEME.Accent
    
    local connection
    connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Keyboard then
            Config.ManualSpamKeybind = input.KeyCode
            
            local keyName = input.KeyCode.Name
            Btn.Text = "Manual Spam Key: " .. keyName .. " [Click to Change]"
            Btn.BackgroundColor3 = THEME.Section
            
            Config.IsListeningForKey = false
            connection:Disconnect()
        end
    end)
end)

-- // 5. OPTIMIZED PHYSICS LOOP //
local Connection = RunService.RenderStepped:Connect(function(dt)
    if not Config.Enabled then return end
    if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then return end

    local ballShadow = workspace:FindFirstChild("FX") and workspace.FX:FindFirstChild("BallShadow")
    local ballObject = workspace:FindFirstChild("Ball")
    
    if not ballObject then
        for _, obj in pairs(workspace:GetChildren()) do
            if obj:IsA("BasePart") and obj.Name == "Part" and obj:FindFirstChildOfClass("Highlight") then
                ballObject = obj
                break
            end
        end
    end

    State.BallShadow = ballShadow
    State.BallObject = ballObject

    if not State.BallShadow or not State.BallObject then
        State.PreviousPosition = nil
        State.PreviousVelocity = nil
        State.ConsecutiveDetections = 0
        State.VelocityHistory = {}
        State.TrajectoryHistory = {}
        State.AccelerationHistory = {}
        State.DirectionHistory = {}
        State.PassByDistanceHistory = {}
        State.SmoothedVelocity = Vector3.new(0, 0, 0)
        State.CloseCombatActive = false
        State.UltraCloseMode = false
        State.IsAccelerated = false
        State.AccelerationBoost = 1.0
        State.IsCurveRecovery = false
        State.CurveRecoveryStart = 0
        State.BackwardCurveDetected = false
        State.UpwardCurveDetected = false
        State.DownwardCurveDetected = false
        State.LeftCurveDetected = false
        State.RightCurveDetected = false
        State.CurveBackDetected = false
        State.CurveBackConfidence = 0
        return
    end

    local rootPart = LocalPlayer.Character.PrimaryPart
    local height = GetVisualHeight(State.BallShadow)
    local currentPos = Vector3.new(State.BallShadow.Position.X, State.BallShadow.Position.Y + height, State.BallShadow.Position.Z)

    if State.PreviousPosition then
        local rawVelocityVec = (currentPos - State.PreviousPosition) / dt
        local velocityMag = rawVelocityVec.Magnitude
        local ping = LocalPlayer:GetNetworkPing()
        local velocityVec = QuantumSmoothVelocity(rawVelocityVec, velocityMag, ping)
        
        local acceleration = DetectAcceleration(velocityVec, velocityMag)
        
        local isSkill, skillBonus = PerfectSkillDetection()
        local curveStrength, curvePrediction, curveType = ThreeSixtyTrajectoryAnalysis(currentPos, velocityVec)
        
        if velocityMag < 5 then
            State.PreviousPosition = currentPos
            State.PreviousVelocity = velocityVec
            State.ConsecutiveDetections = 0
            State.CloseCombatActive = false
            State.UltraCloseMode = false
            State.IsCurveRecovery = false
            State.BackwardCurveDetected = false
            State.UpwardCurveDetected = false
            State.DownwardCurveDetected = false
            State.LeftCurveDetected = false
            State.RightCurveDetected = false
            State.CurveBackDetected = false
            State.CurveBackConfidence = 0
            return
        end

        local dynamicDistance = ZeroMissCompensation(velocityMag, ping, isSkill, skillBonus, curveStrength, State.PerfectConfidence)
        local flatDistance = (Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Magnitude

        UpdateHitboxVisualizer(rootPart.Position, dynamicDistance)

        local isTargeted = ZeroMissTargeting(currentPos, velocityVec, rootPart.Position)

        if Config.Debug and isTargeted then
            local curveBackStatus = State.CurveBackDetected and "CURVE-BACK" or "NORMAL"
            print(string.format("[V14.6 OPTIMIZED] Vel:%.1f | Dist:%.1f/%.1f | CurveBack: %s | Timing Offset: %.3f", 
                velocityMag, flatDistance, dynamicDistance, curveBackStatus, State.OptimalParryOffset or 0))
        end

        if Config.AutoSpam and isTargeted and flatDistance < 45 and velocityMag > 15 then
            ExtremeSpamParry()
        elseif isTargeted and flatDistance <= dynamicDistance then
            TriggerParry()
        end
        
        State.PreviousVelocity = velocityVec
    end

    State.PreviousPosition = currentPos
end)

getgenv()[ScriptKey].Connection = Connection

-- // MANUAL SPAM KEYBIND HANDLER (TOGGLE) //
local ManualSpamConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or Config.IsListeningForKey then return end
    
    if input.KeyCode == Config.ManualSpamKeybind then
        Config.ManualSpam = not Config.ManualSpam
        
        if Config.ManualSpam then
            print("[V14.6 OPTIMIZED] Manual Spam ENABLED - Press " .. Config.ManualSpamKeybind.Name .. " again to disable")
            if not State.ManualSpamRunning then
                State.ManualSpamRunning = true
                task.spawn(ManualSpamLoop)
            end
        else
            print("[V14.6 OPTIMIZED] Manual Spam DISABLED")
        end
    end
end)

getgenv()[ScriptKey].ManualSpamConnection = ManualSpamConnection

-- // 6. KEYBIND HANDLER //
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or Config.IsListeningForKey then return end
    
    if input.KeyCode == Config.MinimizeKeybind then
        if getgenv()[ScriptKey].UI then
            getgenv()[ScriptKey].UI.MainFrame.Visible = not getgenv()[ScriptKey].UI.MainFrame.Visible
        end
    elseif input.KeyCode == Config.ManualSpamKeybind then
        if not Config.Enabled then return end
        
        if not State.IsManualSpamming then
            State.IsManualSpamming = true
            local spamCount = 0
            local maxSpams = 25  -- Reduced from 30
            
            while State.IsManualSpamming and spamCount < maxSpams do
                if Config.AutoCurve then
                    local originalCFrame = Camera.CFrame
                    local curveMode = Config.CurveMode
                    if curveMode == "Random" then
                        local randomModes = {"Up", "Down", "Back", "Left", "Right"}
                        curveMode = randomModes[math.random(1, #randomModes)]
                    end
                    
                    local rad90 = math.rad(90)
                    local curveDirection
                    if curveMode == "Up" then curveDirection = CFrame.Angles(rad90, 0, 0)
                    elseif curveMode == "Down" then curveDirection = CFrame.Angles(-rad90, 0, 0)
                    elseif curveMode == "Back" then curveDirection = CFrame.Angles(0, math.rad(180), 0)
                    elseif curveMode == "Left" then curveDirection = CFrame.Angles(0, rad90, 0)
                    elseif curveMode == "Right" then curveDirection = CFrame.Angles(0, -rad90, 0)
                    end
                    
                    if curveDirection then
                        Camera.CFrame = originalCFrame * curveDirection
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                        task.wait(0.015)  -- Reduced from 0.018
                        Camera.CFrame = originalCFrame
                    end
                else
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                end
                
                spamCount = spamCount + 1
                task.wait(0.02)  -- Reduced from 0.025 for faster response
            end
            
            State.IsManualSpamming = false
        end
    end
end)

-- // 7. INITIALIZATION //
LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(0.5)
    workspace.CurrentCamera.FieldOfView = Config.FOV
    if Config.MaxCamera then
        LocalPlayer.CameraMaxZoomDistance = 9999
        LocalPlayer.CameraMinZoomDistance = 0.5
    end
end)
